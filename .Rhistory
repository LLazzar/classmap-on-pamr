str(data$x)
str(data$y)
pamr=pamr.train(data)
pamr
View(data)
View(data)
thres=pamr.adaptthresh(pamr)
pamr=pamr.train(data, threshold.scale = thres)
pamr
clinical=read.table("sample_datasets/merged_lung_microarray/E-MTAB-6043.sdrf", sep = "\t", header = TRUE)
clinical=read.table("sample_datasets/merged_lung_microarray/E-MTAB-6043.sdrf.txt", sep = "\t", header = TRUE)
View(clinical)
View(clinical)
datar=read.table("sample_datasets/merged_lung_microarray/Combat_filtered_exprs.txt", sep = "\t", header = TRUE)
data=list() #pamr wants list
data$y=as.matrix(clinical[,11])
table(data$y)
which(is.na(data$y))
View(datar)
View(datar)
colnames(datar)
str(clinical)
clinical_ordered <- clinical[order(match(clinical$Characteristics.GEO.sample.accession., col)),]
col=colnames(datar)
clinical_ordered <- clinical[order(match(clinical$Characteristics.GEO.sample.accession., col)),]
View(clinical_ordered)
View(clinical_ordered)
clinical[956,11]
clinical[957,11]
data$y=as.matrix(clinical[140,11])
clinical-ordered <- data.frame(clinical_ordered, row.names = NULL) #reset index
clinical_ordered <- data.frame(clinical_ordered, row.names = NULL) #reset index
View(clinical_ordered)
View(clinical_ordered)
data$y=as.matrix(clinical[956,11])
clinical_ordered[956,11]
clinical_ordered[980,11]
data=list() #pamr wants list
data$y=as.matrix(clinical_ordered[980,11])
data=list() #pamr wants list
data$y=as.matrix(clinical_ordered[,11])
data$x=as.matrix(datar[,1:955])
str(data$x)
str(data$y)
table(data$y)
library(pamr)
pamr=pamr.train(data)
pamr
table(data$y)
str(clinical_ordered)
table(data$y)
clinical_ordered <- subset(clinical_ordered, Characteristics.disease.histology. %in% c("normal histology", "squamous cell carcinoma histology", "large cell carcinoma histology", "adenocarcinoma histology"))
View(clinical_ordered)
View(clinical_ordered)
dat=datar[,clinical_ordered$Characteristics.GEO.sample.accession.]
View(dat)
View(dat)
dat[,635]
colname(dat)[845]
colname(dat)[845]
colnames(dat)[845]
clinical_ordered$Characteristics.GEO.sample.accession.[845]
data=list() #pamr wants list
data$y=as.matrix(clinical_ordered[,11])
data$x=as.matrix(dat)
pamr=pamr.train(data)
pamr
thres=pamr.adaptthresh(pamr)
pamrcv=pamr.cv(pamr, data)
pamrcv
thres=pamr.adaptthresh(pamr)
pamr=pamr.train(data, threshold.scale = thres)
clinical=read.table("sample_datasets/merged_lung_microarray/E-MTAB-6043.sdrf.txt", sep = "\t", header = TRUE)
datar=read.table("sample_datasets/merged_lung_microarray/Combat_filtered_exprs.txt", sep = "\t", header = TRUE)
col=colnames(datar)
clinical_ordered <- clinical[order(match(clinical$Characteristics.GEO.sample.accession., col)),]
clinical_ordered <- data.frame(clinical_ordered, row.names = NULL) #reset index
clinical_ordered <- subset(clinical_ordered, Characteristics.disease.histology. %in% c("normal histology", "squamous cell carcinoma histology", "large cell carcinoma histology", "adenocarcinoma histology"))
dat=datar[,clinical_ordered$Characteristics.GEO.sample.accession.]
colnames(dat)[845]
clinical_ordered$Characteristics.GEO.sample.accession.[845] #ok they matchdata:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAcCAYAAAByDd+UAAAC80lEQVR42u2Wy2sTURTG+wf4QFEwBbFKKbgQFy6SoGJFatUsXGmRbtRqE9TUmcGmSEKNpqFRtMlIjE1EsLGQKNZW+ojgVkEqiI2tuFAER0YtpMnUhtiQ9nq/hEhoJtM8uhIvHGa4c+f85pw557u3qur/oGO92rhmk4Y9rtKwPLWQSsON0+srlZobxByeYU3FoA27TaurNYyx9oAl3Nw+KFy5+17ig9/nPU+lRWdgZsHq+5owOsLSEcOAsLXeHMbassH46i17TRN6a0j0j86k/KE48T6bI67Hv8iN/lli75NI1wOJ2KhdvS8Rk3s6ddgwIm7eY5rAuyXBqrVsy06dfap3QEgEXsRJ79AccTycJRZfjJjuxAh3O0pYPpq+XnLTOU+MdHgy8y22z4m6hq4p+CgOpmaP7tDZJvtGp5P9z+PkVnCWmL0ZZ4wrSi4WMIbPfATu9Y5vydqGa5PwpQjbWH9uFdLofvQlDhhSh4gYvjCokJ20fowjvaiDwtFpuLbWzjERaeyhkSFVjKt0WNYOtg6L8CkLW7erYy2q0T8WTeGfmX3lRZZr52/+TNXUW8LwLRddU7NpUEA1dtMCwT+rBJa1/aeeCPCdB1RpWVenJyx5aXSoRsa1MsATl99KEId8IFUQPvgjiT5DoWBx6HWClDrwTi5Q7xCS8C0D5MahIKjM3HSWAl0Kgxl7IovwLRfhS2cgsgAFYZcUSzFQOZgyUMsOWe8JvyFXcgWjBC0EU04pLZoLjncStBFyJfeyHFQJplg0KF0dVf20EHtiBR3kQpeDKbYFmnMbbdJ2qvoQYqWmB6gYmGLjZ6XtkGFYzO4GlfagorRlN1wI7mnbp0SlMGxTy4p3euPVcse2N9o/GK6LyXJhBro9wUfRGzHtm7N1DfYpfGU5kWEDVmmYMyUfMZCSRv2IiJ9fTIFgbVlHjNzTGg5GNfvMYZQ3ekrfLcy3OSOLMNxjDs+wpqJDVD6Ya/p7TNSyb9KWPjKyPJ6tCOifGH8AFuwin+ZrRG0AAAAASUVORK5CYII=
data=list() #pamr wants list
data$y=as.matrix(clinical_ordered[,11])
data$x=as.matrix(dat)
str(data$x)
str(data$y)
table(data$y)
which(is.na(data$y))
library(pamr)
pamr=pamr.train(data)
thres=pamr.adaptthresh(pamr)
pamr=pamr.train(data, threshold.scale = thres)
pamrcv=pamr.cv(pamr, data)
pamrcv
source("feature_code/R/VCR_pamr.R")
library(classmap)
vcrpamr=vcr.pamr.train(data,pamr, pamrfitcv=pamrcv, threshold=1.5)
silplot(vcrpamr)
?randomForest
rf=randomForest(data$y ~ ., data = t(data$x)))
rf=randomForest(data$y ~ ., data = t(data$x))
library(randomForest)
rf=randomForest(data$y ~ ., data = t(data$x))
thres=pamr.adaptthresh(pamr)
# Main code of examples ####
## a generic microarray dataset form local ####
library(foreign) #to read WEKA arff format
datar=read.arff("sample_datasets/SRBCT.arff")
str(datar) #need manipulation to get to work with pamR
data=list() #pamr wants list
data$y=datar[,ncol(datar)]
data$x=datar[,1:(ncol(datar)-1)]
data$x=t(data$x) #pamr wants nvariable x obervations
str(data$x)
str(data$y)
#fitting
library(pamr)
?pamr.train
pamr=pamr.train(data) #data=SRBCT as pamr paper
pamr #chose a threshold by eye and get index
#producing the output for classmap
vcrpamr=vcr.pamr.train(data=data, pamrfit=pamr, threshold_index = 7) #data is feeded in same format that pam accepts
# loading R function need ####
source("feature_code/R/VCR_pamr.R") #to import special vcr function made for pamr(NSC) classifier
#producing the output for classmap
vcrpamr=vcr.pamr.train(data=data, pamrfit=pamr, threshold_index = 7) #data is feeded in same format that pam accepts
#producing the output for classmap
vcrpamr=vcr.pamr.train(data=data, pamrfit=pamr, threshold = 7) #data is feeded in same format that pam accepts
silplot(vcrpamr) #classLabels = c("EWS","BL","NB","RMS") if you have names
#silhouette visual plot
library(classmap)
silplot(vcrpamr) #classLabels = c("EWS","BL","NB","RMS") if you have names
data$y
posid=vcrpamr$posid
sd=vcrpamr$sd
n=ncol(data$x)
pairwise=matrix(NA, nrow = n, ncol = n)
sdr=sd[posid]
xr=data$x[posid,]
pairwiser=matrix(NA, nrow = n, ncol = n)
xr<- t(apply(t(xr), 1, function(x) x / sdr))
pairwiser=dist(xr)
dim(pairwiser)
pamr
labels=unlist(pamr$yhat[20], use.names = FALSE)
colors <- c("red", "green", "cyan","purple")
col_vec <- colors[match(labels, c("1", "2", "3", "4"))]
labels
col_vec <- colors[match(labels, c(1, 2, 3, 4))]
col_vec
labels
str(labels)
col_vec <- colors[match(labels, c("  1", "  2", "  3", "  4"))]
labels=as.numeric(as.factor(data$y))
labels
col_vec_true = colors[match(data$y, c("  1", "  2", "  3", "  4"))]
intens=rep(NA,length(col_vec_true))
for (i in 1:length(col_vec_true)){
pal <- colorRamp(c(col_vec_true[i], "white"))
intens[i] = rgb(pal(0.9*vcrpamr$PAC[i]), maxColorValue = 255)
}
intens
mds=cmdscale(pairwiser, k=2)
plot(mds, col=col_vec_true, pch=21, bg=intens, cex=0.8)
sd=vcrpamr$sd
n=ncol(data$x)
pairwise=matrix(NA, nrow = n, ncol = n)
x<- t(apply(t(data$x), 1, function(x) x / sd))
pairwise=dist(x)
mds=cmdscale(pairwise, k=2)
plot(mds, col=col_vec_true, pch=21, bg=intens, cex=0.8)
pamr
mds=cmdscale(pairwise, k=2)
plot(mds, col=col_vec_true, pch=21, bg=intens, cex=0.8)
posid=vcrpamr$posid
sd=vcrpamr$sd
n=ncol(data$x)
sdr=sd[posid]
xr=data$x[posid,]
pairwiser=matrix(NA, nrow = n, ncol = n)
xr<- t(apply(t(xr), 1, function(x) x / sdr))
pairwiser=dist(xr)
mds=cmdscale(pairwiser, k=2)
plot(mds, col=col_vec_true, pch=21, bg=intens, cex=0.8)
pamr
#producing the output for classmap
vcrpamr=vcr.pamr.train(data=data, pamrfit=pamr, threshold = 8) #data is feeded in same format that pam accepts
silplot(vcrpamr) #classLabels = c("EWS","BL","NB","RMS") if you have names
intens=rep(NA,length(col_vec_true))
for (i in 1:length(col_vec_true)){
pal <- colorRamp(c(col_vec_true[i], "white"))
intens[i] = rgb(pal(0.9*vcrpamr$PAC[i]), maxColorValue = 255)
}
posid=vcrpamr$posid
sd=vcrpamr$sd
n=ncol(data$x)
sdr=sd[posid]
xr=data$x[posid,]
pairwiser=matrix(NA, nrow = n, ncol = n)
xr<- t(apply(t(xr), 1, function(x) x / sdr))
pairwiser=dist(xr)
mds=cmdscale(pairwiser, k=2)
plot(mds, col=col_vec_true, pch=21, bg=intens, cex=0.8)
silplot(vcrpamr) #classLabels = c("EWS","BL","NB","RMS") if you have names
?classmap
classmpa(vcrpamr, whichclass=1)
classmap(vcrpamr, whichclass=1)
classmap(vcrpamr, whichclass=2)
classmap(vcrpamr, whichclass=3)
classmap(vcrpamr, whichclass=4)
classmap(vcrpamr, whichclass=3)
silplot(vcrpamr) #classLabels = c("EWS","BL","NB","RMS") if you have names
classmap(vcrpamr, whichclass=2)
silplot(vcrpamr) #classLabels = c("EWS","BL","NB","RMS") if you have names
mds=cmdscale(pairwiser, k=2)
plot(mds, col=col_vec_true, pch=21, bg=intens, cex=0.8)
data$y
pamr
pamr$yhat[23]
#farness plot
classmap(vcrpamr, 2) #very very strange behaviour of the curve (opposite)
#farness plot
classmap(vcrpamr, 3) #very very strange behaviour of the curve (opposite)
#farness plot
classmap(vcrpamr, 4) #very very strange behaviour of the curve (opposite)
silplot(vcrpamr) #classLabels = c("EWS","BL","NB","RMS") if you have names
classmap(vcrpamr, whichclass=1)
classmap(vcrpamr, whichclass=2)
classmap(vcrpamr, whichclass=3)
classmap(vcrpamr, whichclass=4)
silplot(vcrpamr) #classLabels = c("EWS","BL","NB","RMS") if you have names
labels=read.csv("sample_datasets/GSE62944/lung_subset/labels.csv")
datar=read.csv("sample_datasets/GSE62944/lung_subset/FC_expression.csv")
covariates=read.csv("sample_datasets/GSE62944/lung_subset/covariates.csv")
library(edgeR)
d <- DGEList(as.matrix(datar[,2:ncol(datar)]))
d <- calcNormFactors(d, method="TMM")
normCounts <- cpm(d)
data=list()
data$y=as.matrix(labels[,2])
data$x=normCounts
str(data$x)
str(data$y)
pamr=pamr.train(data)
library(pamr)
pamr=pamr.train(data)
pamr
?dist
source("feature_code/R/VCR_pamr.R")
library(classmap)
vcrpamr=vcr.pamr.train(data,pamr, pamrfitcv=NULL, threshold=17)
?dist
vcrpamr=vcr.pamr.train(data,pamr, pamrfitcv=NULL, threshold=45)
posid=vcrpamr$posid
sd=vcrpamr$sd
n=ncol(data$x)
pairwise=matrix(NA, nrow = n, ncol = n)
sdr=sd[posid]
xr=data$x[posid,]
pairwiser=matrix(NA, nrow = n, ncol = n)
xr<- t(apply(t(xr), 1, function(x) x / sdr))
pairwiser=dist(xr)
pw_mdS2 <-function(x, sd, prior, weight) { #pairwise mahalobis squared
if(! missing(weight)) {
posid <- (weight > 0)
if(any(posid)) {
weight <- sqrt(weight[posid])
x <- x[posid,  , drop = FALSE] * weight #get only positions non zero positions
}
else {
mat <- outer(rep(1, ncol(x)), log(prior), "*")
dimnames(mat) <- list(NULL, dimnames(centroids)[[2]])
return(mat)
}
}
p=ncol(t(x))
n=nrow(t(x))
pwd=matrix(NA, nrow=n, ncol=n)
sd=sd[posid]
for (i in 1:n){
pwd[,i]=mahalanobis(t(x),t(x)[i,],cov=diag(sd^2))
}
pwd
}
pwd=pw_mdS2(data$x, sd, weight=posid)
mds=cmdscale(pairwiser, k=2)
plot(mds, col=col_vec_true, pch=21, bg=intens, cex=0.8) #how seen by algorithm by trues belonging
dev.off()
plot(mds, col=col_vec_true, pch=21, bg=intens, cex=0.8) #how seen by algorithm by trues belonging
plot(mds)
plot(mds, pch=20)
mds=cmdscale(pwd, k=2)
plot(mds, pch=20)
mds=cmdscale(pwd, k=2)
plot(mds, pch=20)
mds=cmdscale(pairwiser, k=2)
plot(mds, pch=20)
posid=vcrpamr$posid
sd=vcrpamr$sd
n=ncol(data$x)
pairwise=matrix(NA, nrow = n, ncol = n)
sdr=sd[posid]
xr=data$x[posid,]
pairwiser=matrix(NA, nrow = n, ncol = n)
xr<- t(apply(t(xr), 1, function(x) x / sdr))
pairwiser=dist(xr, method="euclidean_squared")
pairwiser=dist(xr, method = "euclidean_squared")
pairwiser= as.matrix(dist(xr)^2)
mds=cmdscale(pairwiser, k=2)
plot(mds, pch=20)
mds=cmdscale(pwd, k=2)
plot(mds, pch=20)
mds=cmdscale(pwd, k=2)
plot(mds, pch=20)
mds=cmdscale(pairwiser, k=2)
plot(mds, pch=20)
mds=cmdscale(pairwiser, k=2)
plot(mds, pch=20)
identical(pwd, pairwiser)
identical(as.matrix(pwd), as.matrix(pairwiser)
)
mds=cmdscale(pwdr, k=2)
mds=cmdscale(pwd, k=2)
plot(mds, pch=20)
pwd[1,1]
as.matrix(pwd)[1,1]
as.matrix(pwd)[1,5]
pairwise[1,5]
pairwiser[1,5]
pamr
vcrpamr=vcr.pamr.train(data,pamr, pamrfitcv=NULL, threshold=23)
posid=vcrpamr$posid
sd=vcrpamr$sd
n=ncol(data$x)
pairwise=matrix(NA, nrow = n, ncol = n)
sdr=sd[posid]
xr=data$x[posid,]
pairwiser=matrix(NA, nrow = n, ncol = n)
xr<- t(apply(t(xr), 1, function(x) x / sdr))
pairwiser=dist(xr)
pairwiser= as.matrix(dist(xr)^2)
pwd=pw_mdS2(data$x, sd, weight=posid)
mds=cmdscale(pwd, k=2)
plot(mds, pch=20)
posid=vcrpamr$posid
sd=vcrpamr$sd
n=ncol(data$x)
pairwise=matrix(NA, nrow = n, ncol = n)
sdr=sd[posid]
xr=data$x[posid,]
pairwiser=matrix(NA, nrow = n, ncol = n)
xr<- t(apply(t(xr), 1, function(x) x / sdr))
pairwiser=dist(xr)
pairwiser= as.matrix(dist(xr)^2)
pwd=pw_mdS2(data$x, sd, weight=posid)
mds=cmdscale(pwd, k=2)
plot(mds, pch=20)
mds=cmdscale(pairwiser, k=2)
plot(mds, pch=20)
dev.off()
plot(mds, pch=20)
#calculating pairwise distance variables selected
posid=vcrpamr$posid
posid
posid=rep(TRUE,length(sd))
sd=vcrpamr$sd
n=ncol(data$x)
pairwise=matrix(NA, nrow = n, ncol = n)
sdr=sd[posid]
xr=data$x[posid,]
pairwiser=matrix(NA, nrow = n, ncol = n)
xr<- t(apply(t(xr), 1, function(x) x / sdr))
pairwiser=dist(xr)
pairwiser= as.matrix(dist(xr)^2)
mds=cmdscale(pairwiser, k=2)
plot(mds, pch=20)
posid
# loading R function need ####
source("feature_code/R/VCR_pamr.R") #to import special vcr function made for pamr(NSC) classifier
# Main code of examples ####
## a generic microarray dataset form local ####
library(foreign) #to read WEKA arff format
datar=read.arff("sample_datasets/Ovarian.arff")
str(datar) #need manipulation to get to work with pamR
data=list() #pamr wants list
data$y=datar[,ncol(datar)]
data$x=datar[,1:(ncol(datar)-1)]
data$x=t(data$x) #pamr wants nvariable x obervations
str(data$x)
str(data$x)
str(data$y)
#fitting
library(pamr)
?pamr.train
pamr=pamr.train(data) #data=SRBCT as pamr paper
pamr #chose a threshold by eye and get index
pamr$prob
yhat=pamr$yhat[3] #choose threshold 6.763
str(pamr$prob) #it's a 3d dim array [i,j,k]=[nobvs,class,thresholdindex]
pprob=pamr$prob[,,3]
ytrue=SRBCT$y
pamr #chose a threshold by eye and get index
#producing the output for classmap
vcrpamr=vcr.pamr.train(data=data, pamrfit=pamr, threshold_index = 9) #data is feeded in same format that pam accepts
#producing the output for classmap
vcrpamr=vcr.pamr.train(data=data, pamrfit=pamr, threshold = 9) #data is feeded in same format that pam accepts
vcrpamr$farness
# Load necessary libraries
library(ggplot2)
library(dplyr)
# Set seed for reproducibility
set.seed(42)
# Generate 5 different groups with different variances
group1 <- rnorm(100, mean = 10, sd = 2)
group2 <- rnorm(100, mean = 20, sd = 4)
group3 <- rnorm(100, mean = 30, sd = 6)
group4 <- rnorm(100, mean = 40, sd = 8)
group5 <- rnorm(100, mean = 50, sd = 10)
# Combine the data into a single data frame
data <- data.frame(
Value = c(group1, group2, group3, group4, group5),
Group = factor(rep(1:5, each = 100))
)
# Visualize the raw data
ggplot(data, aes(x = Group, y = Value, group = Group)) +
geom_boxplot() +
ggtitle("Raw Data") +
theme_minimal()
# Divide by the median within each group
data_normalized <- data %>%
group_by(Group) %>%
mutate(NormalizedValue = Value / median(Value))
# Visualize the normalized data
ggplot(data_normalized, aes(x = Group, y = NormalizedValue, group = Group)) +
geom_boxplot() +
ggtitle("Data Divided by Median") +
theme_minimal()
# Divide by the median within each group
data_normalized <- data %>%
group_by(Group) %>%
mutate(NormalizedValue = Value / mean(Value))
# Visualize the normalized data
ggplot(data_normalized, aes(x = Group, y = NormalizedValue, group = Group)) +
geom_boxplot() +
ggtitle("Data Divided by Median") +
theme_minimal()
# Set seed for reproducibility
set.seed(42)
# Generate 5 different groups with different variances
group1 <- rnorm(100, mean = 10, sd = 2)
group2 <- rnorm(100, mean = 20, sd = 4)
group3 <- rnorm(100, mean = 30, sd = 6)
group4 <- rnorm(100, mean = 40, sd = 8)
group5 <- rnorm(100, mean = 50, sd = 10)
# Combine the data into a single data frame
data <- data.frame(
Value = c(group1, group2, group3, group4, group5),
Group = factor(rep(1:5, each = 100))
)
# Visualize the raw data
ggplot(data, aes(x = Group, y = Value, group = Group)) +
geom_boxplot() +
ggtitle("Raw Data") +
theme_minimal()
# Divide by the median within each group
data_normalized <- data %>%
group_by(Group) %>%
mutate(NormalizedValue = Value / mean(Value))
# Visualize the normalized data
ggplot(data_normalized, aes(x = Group, y = NormalizedValue, group = Group)) +
geom_boxplot() +
ggtitle("Data Divided by Median") +
theme_minimal()
# Load necessary libraries
library(ggplot2)
library(dplyr)
# Set seed for reproducibility
set.seed(42)
# Generate 5 different groups with different variances
group1 <- rnorm(100, mean = 10, sd = 2)
group2 <- rnorm(100, mean = 20, sd = 4)
group3 <- rnorm(100, mean = 30, sd = 6)
group4 <- rnorm(100, mean = 40, sd = 8)
group5 <- rnorm(100, mean = 50, sd = 10)
# Combine the data into a single data frame
data <- data.frame(
Value = c(group1, group2, group3, group4, group5),
Group = factor(rep(1:5, each = 100))
)
# Visualize the raw data
ggplot(data, aes(x = Group, y = Value, group = Group)) +
geom_boxplot() +
ggtitle("Raw Data") +
theme_minimal()
# Divide by the median within each group
data_normalized_median <- data %>%
group_by(Group) %>%
mutate(NormalizedValue = Value / median(Value))
# Visualize the normalized data (dividing by median)
ggplot(data_normalized_median, aes(x = Group, y = NormalizedValue, group = Group)) +
geom_boxplot() +
ggtitle("Data Divided by Median") +
theme_minimal()
# Divide by the mean within each group
data_normalized_mean <- data %>%
group_by(Group) %>%
mutate(NormalizedValue = Value / mean(Value))
# Visualize the normalized data (dividing by mean)
ggplot(data_normalized_mean, aes(x = Group, y = NormalizedValue, group = Group)) +
geom_boxplot() +
ggtitle("Data Divided by Mean") +
theme_minimal()
